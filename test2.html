<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Volleyball Livescore</title>

  <!-- React 18 -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel (JSX i browser) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    :root {
      --bg: #f6f7f9;
      --card: #ffffff;
      --border: #e6e6e6;
      --text: #111827;
      --muted: #6b7280;
      --shadow: 0 1px 2px rgba(0,0,0,0.05);
      --radius: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
    }

    h1 {
      margin: 6px 0 14px;
      font-size: 28px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--border);
      background: #fafafa;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      color: #111;
      user-select: none;
    }

    .filterBtn {
      cursor: pointer;
      outline: none;
      border: 1px solid var(--border);
    }
    .filterBtn:active { transform: translateY(1px); }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #22c55e;
      display: inline-block;
    }
    .dot.gray { background: #9ca3af; }

    /* √ân kamp per linje ‚Äì bredt kort, men responsivt */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 16px;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px 18px;
      box-shadow: var(--shadow);
      cursor: pointer;
      transition: box-shadow 0.15s ease, transform 0.15s ease, border-color 0.15s ease;
      width: 100%;
    }

    .card:hover {
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
      transform: translateY(-1px);
    }

    .card.focused {
      border-color: #111827;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      transform: translateY(-2px);
    }

    .cardHeader {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 12px;
    }

    .compTitle {
      font-weight: 850;
      font-size: 15px;
      line-height: 1.2;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .sub {
      margin-top: 4px;
      color: var(--muted);
      font-size: 12px;
    }

    .status {
      font-size: 12px;
      border: 1px solid var(--border);
      background: #fafafa;
      border-radius: 999px;
      padding: 6px 10px;
      white-space: nowrap;
      color: #111;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .scoreRow {
      display: grid;
      grid-template-columns: 1.2fr auto 1.2fr;
      align-items: center;
      gap: 18px;
      margin-top: 8px;
    }

    .team {
      font-weight: 650;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .team.right {
      justify-content: flex-end;
      text-align: right;
    }

    .teamName {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
      display: inline-block;
    }

    .bigScore {
      text-align: center;
      min-width: 120px;
    }

    .pointsMain {
      font-size: 26px;
      font-weight: 900;
      line-height: 1.1;
    }

    .card.focused .pointsMain {
      font-size: 34px;
    }

    .points {
      margin-top: 4px;
      font-size: 13px;
      color: var(--muted);
    }

    .pointVal {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      min-width: 28px;
      padding: 0 6px;
      border-radius: 8px;
    }

    .pointSep {
      padding: 0 4px;
    }

    @keyframes scoreBlink {
      0%, 100% { background: transparent; }
      25%, 75% { background: #fef3c7; }
      50% { background: #facc15; }
    }

    .pointVal.blinkScore {
      animation: scoreBlink 0.7s ease-in-out 2;
    }

    .setline {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
      margin-top: 14px;
    }

    .setbox {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 8px;
      background: #fcfcfc;
      text-align: center;
    }

    .setbox .label {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .setbox .val {
      font-size: 13px;
      font-weight: 700;
    }

    .meta {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .alert {
      margin-top: 12px;
      padding: 12px;
      border: 1px solid #f2b8b8;
      background: #fff5f5;
      border-radius: 12px;
      color: #7f1d1d;
    }

    .logoBox {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: #e5e7eb;
      border: 1px solid var(--border);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      overflow: hidden;
    }

    .logoBox img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    @media (max-width: 640px) {
      .card {
        padding: 14px;
      }
      .scoreRow {
        gap: 10px;
      }
      .pointsMain {
        font-size: 22px;
      }
      .card.focused .pointsMain {
        font-size: 28px;
      }
    }

    @media (max-width: 480px) {
      .logoBox { width: 18px; height: 18px; border-radius: 5px; }
      .scoreRow {
        grid-template-columns: 1fr;
        row-gap: 6px;
        text-align: center;
      }
      .team.right {
        justify-content: center;
        text-align: center;
      }
    }

    .focusBar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
      margin-bottom: 4px;
      gap: 10px;
      flex-wrap: wrap;
    }

    .focusInfo {
      font-size: 13px;
      color: var(--muted);
    }

    .backBtn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #111827;
      color: #fff;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .backBtn:hover {
      background: #020617;
    }

    /* Serve-ikon (SVG) ‚Äì stort og plassert ved poeng */
    .serveIcon {
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .serveIcon svg {
      width: 100%;
      height: 100%;
    }

    .serveIcon.home {
      color: #2563eb; /* bl√• for hjemmelag */
    }

    .serveIcon.away {
      color: #dc2626; /* r√∏d for bortelag */
    }

    .card.focused .serveIcon {
      width: 36px;
      height: 36px;
    }

    @keyframes hotPulse {
      0%   { transform: scale(1);   filter: none; }
      50%  { transform: scale(1.25); filter: drop-shadow(0 0 6px currentColor); }
      100% { transform: scale(1);   filter: none; }
    }

    .serveIcon.hot {
      animation: hotPulse 0.9s ease-in-out infinite;
    }

    /* Serve/side-out/break-point labels i fokusvisning */
    .serveInfoRow {
      margin-top: 4px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #4b5563;
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
    }

    .playLabel {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #e5e7eb;
      font-size: 10px;
    }

    .playLabel.break-point {
      background: #fee2e2;
      color: #b91c1c;
    }

    .playLabel.side-out {
      background: #e0f2fe;
      color: #0369a1;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useCallback, useEffect, useMemo, useRef, useState, memo } = React;

    const API_BASE = "https://volleyball.ronesse.no";
    const POLL_MS = 5000;

    function safeArray(x) { return Array.isArray(x) ? x : []; }

    function formatTs(tsSeconds) {
      if (!tsSeconds) return "";
      const d = new Date(tsSeconds * 1000);
      return d.toLocaleString("nb-NO", {
        hour: "2-digit",
        minute: "2-digit",
        day: "2-digit",
        month: "short",
      });
    }

    function liveLabel(statusType) {
      const t = String(statusType || "").toLowerCase();
      if (t.includes("inprogress") || t.includes("live") || t.includes("inplay")) return "LIVE";
      if (t.includes("finished") || t.includes("ended")) return "SLUTT";
      if (t.includes("not") || t.includes("sched")) return "KOMMER";
      return statusType || "‚Äî";
    }

    function isLiveStatus(statusType) {
      const t = String(statusType || "").toLowerCase();
      return t.includes("inprogress") || t.includes("live") || t.includes("inplay");
    }

    function statusDot(statusType) {
      const t = String(statusType || "").toLowerCase();
      if (t.includes("inprogress") || t.includes("live") || t.includes("inplay")) return "dot";
      if (t.includes("finished") || t.includes("ended")) return "dot gray";
      return "dot gray";
    }

    function normalizeGroupType(v) {
      if (v == null) return null;
      const s = String(v).trim().toLowerCase();
      if (!s) return null;
      if (s === "mizuno") return "mizuno";
      if (s === "abroad") return "abroad";
      return s;
    }

    // finn p√•g√•ende sett + poeng
    function currentPoints(ev) {
      let setNo = null;
      const m = String(ev.status_desc || "").match(/(\d+)/);
      if (m) setNo = Number(m[1]);

      if (!setNo) {
        for (let i = 5; i >= 1; i--) {
          if (ev["home_p" + i] != null || ev["away_p" + i] != null) { setNo = i; break; }
        }
      }

      return {
        setNo: setNo,
        home: setNo ? ev["home_p" + setNo] : null,
        away: setNo ? ev["away_p" + setNo] : null,
      };
    }

    const FILTERS = [
      { key: "all", label: "Alle", empty: "Det er ingen p√•g√•ende kamper for √∏yeblikket." },
      { key: "mizuno", label: "Mizuno Norge", empty: "Det er ingen p√•g√•ende kamper i Norsk Mizunoliga." },
      { key: "abroad", label: "Norske spillere i utlandet", empty: "Det er ingen norske spillere i aksjon for √∏yeblikket." },
    ];

    const SetBox = memo(function SetBox(props) {
      const style = props.highlight ? { borderColor: "#c7d2fe", background: "#eef2ff" } : null;
      return (
        <div className="setbox" style={style}>
          <div className="label">{props.label}</div>
          <div className="val">{props.home ?? "‚Äî"} - {props.away ?? "‚Äî"}</div>
        </div>
      );
    });

    // logo-caching
    const imgStatusCache = new Map();

    function useImageStatus(src) {
      const [status, setStatus] = useState(src ? (imgStatusCache.get(src) || "loading") : "none");

      useEffect(() => {
        if (!src) { setStatus("none"); return; }

        const cached = imgStatusCache.get(src);
        if (cached) { setStatus(cached); return; }

        setStatus("loading");
        const img = new Image();

        img.onload = function () {
          imgStatusCache.set(src, "ok");
          setStatus("ok");
        };

        img.onerror = function () {
          imgStatusCache.set(src, "fail");
          setStatus("fail");
        };

        img.src = src;
      }, [src]);

      return status;
    }

    function LogoBox(props) {
      const src = props.src;
      const status = useImageStatus(src);

      if (!src || status === "fail" || status === "none" || status === "loading") {
        return <span className="logoBox" aria-hidden="true"></span>;
      }

      return (
        <span className="logoBox" aria-hidden="true">
          <img src={src} alt="" loading="lazy" />
        </span>
      );
    }

    function ServeIcon({ side, hot }) {
      const className =
        "serveIcon " +
        (side === "home" ? "home" : "away") +
        (hot ? " hot" : "");

      return (
        <span
          className={className}
          title={hot ? "Break-point (poeng p√• egen serve)" : "Server"}
        >
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <circle
              cx="12"
              cy="12"
              r="9"
              fill="none"
              stroke="currentColor"
              strokeWidth="1.8"
            />
            <path
              d="M5 7a9 9 0 0 0 6 3.5M9 3.5A9 9 0 0 1 15.5 9M5 12a9 9 0 0 0 6.5 8M12 5a9 9 0 0 1 7 5.5"
              fill="none"
              stroke="currentColor"
              strokeWidth="1.4"
            />
          </svg>
        </span>
      );
    }

    function getHomeId(ev) { return ev.home_team_id ?? ev.home_teams_id ?? null; }
    function getAwayId(ev) { return ev.away_team_id ?? ev.away_teams_id ?? null; }

    function getTournamentId(ev) {
      if (ev.tournament_id != null) return ev.tournament_id;
      if (ev.tournamentId != null) return ev.tournamentId;
      if (ev.tournament && ev.tournament.id != null) return ev.tournament.id;
      if (typeof ev.tournament === "number" || typeof ev.tournament === "string") return ev.tournament;
      return null;
    }

    function teamLogoUrl(teamId) {
      if (teamId == null) return null;
      return API_BASE + "/img/teams/" + String(teamId) + ".png";
    }

    function tournamentLogoUrl(tournamentId) {
      if (tournamentId == null) return null;
      return API_BASE + "/img/tournaments/" + String(tournamentId) + ".png";
    }

    function compHeaderText(ev) {
      const t = ev.tournament_name ? String(ev.tournament_name) : "";
      const s = ev.season_name ? String(ev.season_name) : "";
      if (t && s) return t + " ¬∑ " + s;
      return t || s || "‚Äî";
    }

    function eventKey(ev) {
      return (
        ev.event_id ??
        ev.custom_id ??
        String(ev.start_ts ?? "") + "-" + String(ev.home_team_name ?? "") + "-" + String(ev.away_team_name ?? "")
      );
    }

    function EventCard(props) {
      const { ev, flashInfo, serveInfo, playLabelInfo, isFocused, onClick } = props;

      const label = liveLabel(ev.status_type);
      const p = currentPoints(ev);

      const setsHome = (ev.home_sets ?? 0);
      const setsAway = (ev.away_sets ?? 0);

      const currentSetText = p.setNo ? (String(p.setNo) + ". sett") : (ev.status_desc || "P√•g√•r");

      const homeId = getHomeId(ev);
      const awayId = getAwayId(ev);
      const tournamentId = getTournamentId(ev);

      const homeLogo = teamLogoUrl(homeId);
      const awayLogo = teamLogoUrl(awayId);
      const tourLogo = tournamentLogoUrl(tournamentId);

      const isServingHome = serveInfo && serveInfo.side === "home";
      const isServingAway = serveInfo && serveInfo.side === "away";
      const hotHome = isServingHome && serveInfo.hot;
      const hotAway = isServingAway && serveInfo.hot;

      const cls = "card" + (isFocused ? " focused" : "");

      let playText = null;
      if (playLabelInfo && playLabelInfo.type === "break-point") {
        playText = "Break-point";
      } else if (playLabelInfo && playLabelInfo.type === "side-out") {
        playText = "Side-out";
      }

      return (
        <div className={cls} onClick={onClick} role="button">
          <div className="cardHeader">
            <div>
              <div className="compTitle">
                <LogoBox src={tourLogo} />
                <span>{compHeaderText(ev)}</span>
              </div>
              <div className="sub">{ev.group_type ? String(ev.group_type) : ""}</div>
            </div>

            <div className="status" title={ev.status_desc || ""}>
              <span className={statusDot(ev.status_type)}></span>
              {label + (ev.status_desc ? " ¬∑ " + String(ev.status_desc) : "")}
            </div>
          </div>

          <div className="scoreRow">
            <div className="team">
              <LogoBox src={homeLogo} />
              <span className="teamName">{ev.home_team_name}</span>
            </div>

            <div className="bigScore">
              <div className="pointsMain">
                {/* Hjemme: ikon til venstre for poeng */}
                <span
                  key={"ph-" + (flashInfo.home || 0)}
                  className={"pointVal" + (flashInfo.home ? " blinkScore" : "")}
                >
                  {isServingHome && <ServeIcon side="home" hot={hotHome} />}
                  {p.home ?? "‚Äî"}
                </span>

                <span className="pointSep">-</span>

                {/* Borte: ikon til h√∏yre for poeng */}
                <span
                  key={"pa-" + (flashInfo.away || 0)}
                  className={"pointVal" + (flashInfo.away ? " blinkScore" : "")}
                >
                  {p.away ?? "‚Äî"}
                  {isServingAway && <ServeIcon side="away" hot={hotAway} />}
                </span>
              </div>

              <div className="points">
                {setsHome} - {setsAway} i sett
                {p.setNo ? (" ¬∑ " + currentSetText) : ""}
              </div>

              {isFocused && (isServingHome || isServingAway) && (
                <div className="serveInfoRow">
                  <div>
                    Serve ¬∑ {isServingHome ? ev.home_team_name : ev.away_team_name}
                  </div>
                  {playText && (
                    <div className={
                      "playLabel " +
                      (playLabelInfo.type === "break-point" ? "break-point" : "side-out")
                    }>
                      {playText}
                    </div>
                  )}
                </div>
              )}
            </div>

            <div className="team right">
              <LogoBox src={awayLogo} />
              <span className="teamName">{ev.away_team_name}</span>
            </div>
          </div>

          <div className="setline">
            <SetBox label="1" home={ev.home_p1} away={ev.away_p1} highlight={p.setNo === 1} />
            <SetBox label="2" home={ev.home_p2} away={ev.away_p2} highlight={p.setNo === 2} />
            <SetBox label="3" home={ev.home_p3} away={ev.away_p3} highlight={p.setNo === 3} />
            <SetBox label="4" home={ev.home_p4} away={ev.away_p4} highlight={p.setNo === 4} />
            <SetBox label="5" home={ev.home_p5} away={ev.away_p5} highlight={p.setNo === 5} />
          </div>

          <div className="meta">
            <span>Start: {formatTs(ev.start_ts)}</span>
            <span>Event ID: {ev.event_id ?? "‚Äî"}</span>
          </div>
        </div>
      );
    }

    function App() {
      const [events, setEvents] = useState([]);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState("");
      const [filter, setFilter] = useState("all");
      const [flash, setFlash] = useState({});
      const [serve, setServe] = useState({});
      const [playLabel, setPlayLabel] = useState({});
      const [focusedKey, setFocusedKey] = useState(null);

      const pollRef = useRef(null);
      const abortLiveRef = useRef(null);
      const serveRef = useRef({});

      const fetchJson = useCallback(async (path, signal) => {
        const res = await fetch(API_BASE + path, {
          headers: { "Accept": "application/json" },
          signal: signal,
          cache: "no-store",
        });
        if (!res.ok) throw new Error(String(res.status) + " " + String(res.statusText));
        return res.json();
      }, []);

      const loadLive = useCallback(async () => {
        if (abortLiveRef.current) abortLiveRef.current.abort();
        const controller = new AbortController();
        abortLiveRef.current = controller;

        try {
          setError("");
          const data = await fetchJson("/live", controller.signal);

          const newServe = {};
          const newPlayLabel = {};

          setEvents(prevEvents => {
            const prevPointsMap = new Map();
            for (let i = 0; i < prevEvents.length; i++) {
              const ev = prevEvents[i];
              prevPointsMap.set(eventKey(ev), currentPoints(ev));
            }

            const prevServeMap = serveRef.current || {};
            const nextEvents = safeArray(data);
            const newFlash = {};
            const base = Date.now();

            for (let i = 0; i < nextEvents.length; i++) {
              const ev = nextEvents[i];
              const key = eventKey(ev);
              const p = currentPoints(ev);
              const prev = prevPointsMap.get(key) || {};
              const prevServe = prevServeMap[key] || null;

              let sideScored = null;

              if (p.home != null && prev.home != null && p.home > prev.home) {
                sideScored = "home";
                if (!newFlash[key]) newFlash[key] = {};
                newFlash[key].home = base + Math.random();
              }
              if (p.away != null && prev.away != null && p.away > prev.away) {
                sideScored = "away";
                if (!newFlash[key]) newFlash[key] = {};
                newFlash[key].away = base + Math.random();
              }

              let currentServe = prevServe;
              let label = null;

              if (sideScored) {
                if (prevServe && prevServe.side === sideScored) {
                  // poeng p√• egen serve -> break-point
                  currentServe = { side: sideScored, hot: true };
                  label = { side: sideScored, type: "break-point" };
                } else if (prevServe && prevServe.side && prevServe.side !== sideScored) {
                  // serve bytter lag -> side-out
                  currentServe = { side: sideScored, hot: false };
                  label = { side: sideScored, type: "side-out" };
                } else {
                  // ingen tidligere serve registrert ‚Äì sett server, ingen label
                  currentServe = { side: sideScored, hot: false };
                }
              }

              newServe[key] = currentServe || null;
              if (label) newPlayLabel[key] = label;
            }

            setFlash(newFlash);
            return nextEvents;
          });

          serveRef.current = newServe;
          setServe(newServe);
          setPlayLabel(newPlayLabel);
        } catch (e) {
          if (String(e && e.name) === "AbortError") return;
          setError(String((e && e.message) ? e.message : e));
        } finally {
          setLoading(false);
        }
      }, [fetchJson]);

      useEffect(() => {
        loadLive();
        pollRef.current = setInterval(loadLive, POLL_MS);
        return () => {
          if (pollRef.current) clearInterval(pollRef.current);
          if (abortLiveRef.current) abortLiveRef.current.abort();
        };
      }, [loadLive]);

      const liveEvents = useMemo(() => {
        return events.filter(ev => isLiveStatus(ev.status_type));
      }, [events]);

      const counts = useMemo(() => {
        let miz = 0, abr = 0;
        for (let i = 0; i < liveEvents.length; i++) {
          const gt = normalizeGroupType(liveEvents[i].group_type);
          if (gt === "mizuno") miz++;
          else if (gt === "abroad") abr++;
        }
        return { all: liveEvents.length, mizuno: miz, abroad: abr };
      }, [liveEvents]);

      const filtered = useMemo(() => {
        const arr = liveEvents.slice();
        arr.sort((a, b) => (a.start_ts ?? 0) - (b.start_ts ?? 0));
        if (filter === "all") return arr;
        return arr.filter(ev => normalizeGroupType(ev.group_type) === filter);
      }, [liveEvents, filter]);

      const visible = useMemo(() => {
        if (!focusedKey) return filtered;
        const found = filtered.find(ev => eventKey(ev) === focusedKey)
          || liveEvents.find(ev => eventKey(ev) === focusedKey);
        return found ? [found] : filtered;
      }, [filtered, focusedKey, liveEvents]);

      const currentFilterObj = FILTERS.find(x => x.key === filter);

      return (
        <div className="wrap">
          <h1>üèê Livescore</h1>

          <div className="topbar">
            <div className="badges">
              <span className="badge">
                <span className="dot" style={{ background: "#22c55e" }}></span>
                Oppdaterer hvert {Math.round(POLL_MS / 1000)}s
              </span>
              <span className="badge">
                {visible.length} vises (LIVE totalt {counts.all})
              </span>
            </div>
            <div className="badges">
              <span className="badge" style={{ color: "#6b7280" }}>Kilde: /live</span>
              <span className="badge" style={{ color: "#6b7280" }}>Logo: /img/teams + /img/tournaments</span>
            </div>
          </div>

          <div className="focusBar">
            <div className="badges" style={{ marginBottom: 4 }}>
              {FILTERS.map(f => {
                const active = filter === f.key;
                const n = (f.key === "all") ? counts.all : (f.key === "mizuno") ? counts.mizuno : counts.abroad;

                return (
                  <button
                    key={f.key}
                    onClick={() => { setFilter(f.key); }}
                    className="badge filterBtn"
                    style={{
                      background: active ? "#111827" : "#fafafa",
                      color: active ? "#ffffff" : "#111827",
                      borderColor: active ? "#111827" : "var(--border)",
                    }}
                    title={f.label}
                  >
                    {f.label} ({n})
                  </button>
                );
              })}
            </div>

            {focusedKey && (
              <button className="backBtn" onClick={() => setFocusedKey(null)}>
                ‚Üê Tilbake til alle kamper
              </button>
            )}
          </div>

          {focusedKey && (
            <div className="focusInfo">
              Viser √©n kamp i fokus. Klikk p√• knappen over for √• g√• tilbake.
            </div>
          )}

          {error && <div className="alert">Feil: {error}</div>}
          {loading && <div style={{ marginTop: 10, color: "#6b7280" }}>Laster‚Ä¶</div>}

          {!loading && !error && visible.length === 0 && (
            <div className="card" style={{ marginTop: 10, cursor: "default" }}>
              <div style={{ fontWeight: 800, marginBottom: 6 }}>Ingen livekamper</div>
              <div style={{ color: "#6b7280" }}>
                {currentFilterObj?.empty}
              </div>
            </div>
          )}

          <div className="grid">
            {visible.map(ev => {
              const key = eventKey(ev);
              const flashInfo = flash[key] || {};
              const serveInfo = serve[key] || {};
              const playLabelInfo = playLabel[key] || null;
              const isFocused = focusedKey === key;
              return (
                <EventCard
                  key={key}
                  ev={ev}
                  flashInfo={flashInfo}
                  serveInfo={serveInfo}
                  playLabelInfo={playLabelInfo}
                  isFocused={isFocused}
                  onClick={() => setFocusedKey(key)}
                />
              );
            })}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
